
Safe entity classes
===================

General
--------
A safe class has a private Id property, a private default constructor, depending on type, 
a private settable CorporateId, and a public constructor which takes a CorporateAccessToken or, 
even better, a reference to an associated (parent) entity which provides the CorporateId. 
To insert such a type the public constructor must be used to create an object with zero Id, 
but a checkable and immutable CorporateId. Otherwise the object can only be instantiated by 
the db framework, which uses the private contructor and generally doesn't care about 
property access scoping.

In order to get anything done we'll also need to update entities and their associated
database records. For safe classes we should never update Id and CorporateId properties,
but there might also be more properties that should never change for an entity, and so,
should never be updated. 

An easy way could could be to simply differentiate between mutable and immutable 
properties with public/private setters. In the code we simple set the public properties 
of the entity and at some point call db.Update, which enumerates all properties with a
public setter an updates those fields in the db. The problem is that it isn't safe. 

As soon as we mutate the entity in the application, we create a scenario where the 
application and the database might be in disagreement over what state the entity is 
in. This would happen if an exception was thrown during the database update. In that case
the application should rollback it's changes to the entity in order to retain consistency,
something that might not be so easy. 

One approach to deal with theese kinds over situations is to use 
[COW](https://en.wikipedia.org/wiki/Copy-on-write) principle for 
changes. C# does it for strings, file systems does it, and we can too.

To enforce true COW we'll need to make the 'mutable' properties of our entity classes
non-public, and, provide a reasonably simple alternative for registering the desired
changes. 

We can't simply make the properties *private*, since that indicates total immutability.
*Protected* doesn't really work either in this case. The only remaining alternative is
*internal*, which also fits somewhat ok with the sematics we're trying to convey.

*Protected* is now used to indicate an id property for an associated entity. Making the
id property *protected*, means that the association must be set using a valid entity, rather
than just its id. Setter methods for these protected properties are autogenerated if
there is a matching id/virtual prop pair, for instance:
        public Id<CampaignPoco> CampaignId { get; protected set; }
        public virtual CampaignPoco Campaign { get; protected set; }

*Private protected* can be used to indicate that the property can only be modified by code
in the entity class itself, or the Ext class.
This is useful for automatic handling of properties like LastModifiedTime.
Using *private protected* also means that the property is not expected when deserialing.

*Protected internal* is used to indicated that the property can be changed by code, but
shouldn't be set from a deserialized entity object. LastModifiedTime is again a good
example, we want to allow code to explicitly set it (unlike the automatic handling
with private protected), but it should not be copied from deserialized entities.


Before showing how to operate on a safe entity class, take a look at how it's declared:

```C#
    public partial class IncomingCall : //Explanations about 'partial' are in Efficiency part.
        HasClone<IncomingCall>,  // Implements COW semantics
        IHasAutoIncrementedId<IncomingCall>,
        IHasCorporateId,
        IIsInsertable,
        IIsUpdatable
    {
        // Needed for ORM frameworks
        private IncomingCall() { }

        // The only way to create an object for insertion.
        // Includes parameters for all immutable properties
        public IncomingCall( CorporateAccessToken corporate, DateTime time, string callingNumber, string calledNumber )
        {
            CorporateId = corporate.CorporateId;
            Time = time;
            CallingNumber = callingNumber;
            CalledNumber = calledNumber;
        }

        // These will only ever be set via the constructor or by the ORM
        #region Immutable properties
        public Id<IncomingCall> Id { get; private set; }
        public Id<Corporate> CorporateId { get; private set; }
        public DateTime Time { get; private set; }
        public string CallingNumber { get; private set; }
        public string CalledNumber { get; private set; }
        #endregion

        // Notice the internal setter. We can't change these directly, but they
        // can be change through some COW mechanism.
        #region Updatable properties
        public int? CallId { get; internal set; }
        public ReturnCallManagerResult? Result { get; internal set; }
        public bool Transfered { get; internal set; }
        #endregion
    }

```



Load, change and save in a single action:
```C#
    dbFactory.RunReadWriteAction( db => {
        var incomingCallProxy2 = db.IncomingCalls.Single( _ => _.Id == 42 ).ForUpdate();
        incomingCallProxy2
            .Set( _ => _.Result, ReturnCallManagerResult.ItemProcessed )
            .Set( _ => _.Transfered, true );
        db.Update( incomingCallProxy );
    } );
```


Example of keeping a tracking proxy around for a while:
```C#
    var incomingCallProxy = dbFactory.RunReadWrite( db =>  db.IncomingCalls.Single( _ => _.Id == 42 ) ).ForUpdate();

    ... stuff happens ...

    var incomingCall = incomingCallProxy.Entity;
    Foo( incomingCall.Id );

    ... stuff stuff ...

    incomingCallProxy
        .Set( _ => _.Result, ReturnCallManagerResult.ItemProcessed )
        .Set( _ => _.Bar, incomingCall.Bar + 10 );

    ... more stuff happens ...

    dbFactory.RunReadWriteAction( db => db.Update( incomingCallProxy ) );
```


And finally with proper COW
```C#
    var incomingCallProxy = dbFactory.RunReadWrite( db =>  db.IncomingCalls.Single( _ => _.Id == 42 ) ).ForUpdate();
    var incomingCall = incomingCallProxy.Entity;

    ... stuff stuff ...

    incomingCallProxy
        .Set( _ => _.Result, ReturnCallManagerResult.ItemProcessed )
        .Set( _ => _.Bar, incomingCall.Bar + 10 );

    ... more stuff happens ...

    // UpdateAndCloneWith clones before it updates the db, so a transaction 
    // isn't really needed.
    incomingCall = dbFactory.RunReadWriteAction( db => db.UpdateAndCloneWith( incomingCallProxy ) );
    incomingCallProxy = incomingCall.ForUpdate();

    // Or alternatively
    incomingCallProxy = dbFactory.RunReadWriteAction( db => db.UpdateAndCloneWith( incomingCallProxy ) ).ForUpdate();
    var incomingCall = incomingCallProxy.Entity;
```

A more compact example:
```C#
    /// incomingCall was loaded earlier
    incomingCall = dbFactory.RunReadWrite( db =>
        db.UpdateAndCloneWith( incomingCall.ForUpdate()
            .Set( _ => _.CallId, dialerContext.LeadCall.Id )
            .Set( _ => _.Result, ReturnCallManagerResult.Connected ) );
```

The change tracker also works for classes that don't implement IHasCloneWith, although the ForUpdate
extension method requires IIsUpdatable.

Limitations
-----------

Only top level properties are supported by the proxy.Set syntax, this is by design. 

The primary reason for this decision, is that otherwise all entities with complex
propeties would have to implement their own Clone function, to avoid shallow copies
of references to the original values.

Efficiency
----------

While the syntax with an expression directly in the Set call is pretty, it's also 
somewhat inefficient. Therefore it's recommended to cache this expression in places
where the Set method is called alot. 

There is now an automated way of generating cached expressions.

Enitity classes marked partial and inheriting from IIsUpdatable will get a pair partial
class with properties that cache the relevant details to work effectively with COW 
proxies + an additional static class that implement convenient extension methods for
working with COW proxies;

Example of generated helper classes:
```C#
    using System;
    using System.Linq.Expressions;

    using Actimizer.LRM.BusinessLogic.Entity;

    namespace Actimizer.LRM.DBEntities
    {
        public static class IncomingCallExt
        {
            public static ExtendedPropertyInfo<int?> CallIdExtInfo { get; } = ExtendedPropertyInfoExtensions.GetExtendedPropertyInfo<IncomingCall,int?>( _ => _.CallId );
            public static IEntityUpdateProxy<IncomingCall> SetCallId( this IEntityUpdateProxy<IncomingCall> proxy, int? val ) => proxy.Set( CallIdExtInfo, val );
            public static ExtendedPropertyInfo<ReturnCallManagerResult?> ResultExtInfo { get; } = ExtendedPropertyInfoExtensions.GetExtendedPropertyInfo<IncomingCall,ReturnCallManagerResult?>( _ => _.Result );
            public static IEntityUpdateProxy<IncomingCall> SetResult( this IEntityUpdateProxy<IncomingCall> proxy, ReturnCallManagerResult? val ) => proxy.Set( ResultExtInfo, val );
            public static ExtendedPropertyInfo<bool> TransferedExtInfo { get; } = ExtendedPropertyInfoExtensions.GetExtendedPropertyInfo<IncomingCall,bool>( _ => _.Transfered );
            public static IEntityUpdateProxy<IncomingCall> SetTransfered( this IEntityUpdateProxy<IncomingCall> proxy, bool val ) => proxy.Set( TransferedExtInfo, val );
        }

        public partial class IncomingCall
        {
            public static ExtendedPropertyInfo<int?> CallIdExtInfo { get; } = IncomingCallExt.CallIdExtInfo;
            public static ExtendedPropertyInfo<ReturnCallManagerResult?> ResultExtInfo { get; } = IncomingCallExt.ResultExtInfo;
            public static ExtendedPropertyInfo<bool> TransferedExtInfo { get; } = IncomingCallExt.TransferedExtInfo;
        }
    }
```


Examples of use:
```C#
    proxy.SetResult( ReturnCallManagerResult.Something );

    // or

    proxy.Set( IncomingCall.ResultExtInfo, ReturnCallManagerResult.Something );
```





- Enforces security in relation to multi-tenancy
- Ensures data consistency by implementing COW semantics around update statements
- Facilitates change logging via the UpdateProxy
- Ensures data integrity and security, by encoding mutability and associations on the entities via private/protected/internal semantics,
  supported by code generation.